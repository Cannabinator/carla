<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>V2V LiDAR Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
        }
        
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            min-width: 250px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #info-panel h2 {
            margin-bottom: 10px;
            color: #4CAF50;
            font-size: 18px;
        }
        
        #info-panel .stat {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #info-panel .stat:last-child {
            border-bottom: none;
        }
        
        #info-panel .stat-label {
            color: #aaa;
        }
        
        #info-panel .stat-value {
            color: #fff;
            font-weight: bold;
        }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .status-connected {
            background-color: #4CAF50;
            box-shadow: 0 0 10px #4CAF50;
        }
        
        .status-disconnected {
            background-color: #f44336;
        }
        
        #legend {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #legend h3 {
            margin-bottom: 10px;
            font-size: 16px;
            color: #4CAF50;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border-radius: 3px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #controls h3 {
            margin-bottom: 10px;
            font-size: 16px;
            color: #4CAF50;
        }
        
        #controls button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px 0;
            width: 100%;
            font-size: 14px;
        }
        
        #controls button:hover {
            background: #45a049;
        }
        
        #controls button:active {
            background: #3d8b40;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>
        
        <div id="info-panel">
            <h2>
                <span class="status-indicator" id="status-indicator"></span>
                V2V LiDAR Stream
            </h2>
            <div class="stat">
                <span class="stat-label">Points:</span>
                <span class="stat-value" id="point-count">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Vehicles:</span>
                <span class="stat-value" id="vehicle-count">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">FPS:</span>
                <span class="stat-value" id="fps">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Latency:</span>
                <span class="stat-value" id="latency">0 ms</span>
            </div>
        </div>
        
        <div id="legend">
            <h3>Semantic Labels</h3>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #808080;"></div>
                <span>Unlabeled (0)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #708090;"></div>
                <span>Building (1)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #ff0000;"></div>
                <span>Fence (2)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #4169E1;"></div>
                <span>Vehicle (10)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #FF1493;"></div>
                <span>Pedestrian (4)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #00FF00;"></div>
                <span>Vegetation (9)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #A9A9A9;"></div>
                <span>Road (7)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #FFFF00;"></div>
                <span>Traffic Sign (12)</span>
            </div>
        </div>
        
        <div id="controls">
            <h3>Controls</h3>
            <button onclick="resetCamera()">Reset Camera</button>
            <button id="follow-btn" onclick="toggleFollowMode()">Enable Follow</button>
            <button id="freefly-btn" onclick="toggleFreeFly()">Enable Free-Fly</button>
            <button id="size-btn" onclick="togglePointSize()">Point Size: 0.5</button>
            <button onclick="toggleGrid()">Toggle Grid</button>
        </div>
        
        <div class="loading" id="loading">Connecting...</div>
    </div>
    
    <!-- Three.js and OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    
    <script>
        // CARLA Semantic Tag Colors (based on CARLA documentation)
        const SEMANTIC_COLORS = {
            0: 0x808080,   // Unlabeled - Gray
            1: 0x708090,   // Building - Slate Gray
            2: 0xff0000,   // Fence - Red
            3: 0x800080,   // Other - Purple
            4: 0xFF1493,   // Pedestrian - Deep Pink
            5: 0x00CED1,   // Pole - Dark Turquoise
            6: 0x32CD32,   // RoadLine - Lime Green
            7: 0xA9A9A9,   // Road - Dark Gray
            8: 0xD2B48C,   // Sidewalk - Tan
            9: 0x00FF00,   // Vegetation - Green
            10: 0x4169E1,  // Vehicle - Royal Blue
            11: 0xFFFFFF,  // Wall - White
            12: 0xFFFF00,  // TrafficSign - Yellow
            13: 0x87CEEB,  // Sky - Sky Blue
            14: 0x8B4513,  // Ground - Saddle Brown
            15: 0xFF8C00,  // Bridge - Dark Orange
            16: 0x9370DB,  // RailTrack - Medium Purple
            17: 0x228B22,  // GuardRail - Forest Green
            18: 0xFFD700,  // TrafficLight - Gold
            19: 0xB8860B,  // Static - Dark Golden Rod
            20: 0x00FFFF,  // Dynamic - Cyan
            21: 0x8A2BE2,  // Water - Blue Violet
            22: 0xA52A2A   // Terrain - Brown
        };
        
        // Scene setup
        let scene, camera, renderer;
        let orbitControls;
        let pointerControls;
        let pointCloud, gridHelper;
        let ws;
        let frameCount = 0;
        let lastFrameTime = Date.now();
        let lastDataTime = Date.now();
        let pointSize = 0.5;  // Larger points for better visibility
        let showGrid = true;
        let followMode = false;  // Start in orbit mode for easier initial orientation
        let freeFlyMode = false;
        let egoPosition = { x: 0, y: 0, z: 0 };  // Track ego vehicle position
        
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            scene.fog = new THREE.Fog(0x1a1a1a, 50, 200);
            
            // Camera (CARLA uses Z-up, X-forward coordinate system)
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(-25, 0, 20);  // Behind and above for better view
            camera.up.set(0, 0, 1);  // Z-up for CARLA
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Dual control system: FlyControls for free movement OR follow mode
            // Use PointerLockControls for FPS-style free movement
            pointerControls = new THREE.PointerLockControls(camera, renderer.domElement);
            
            // OrbitControls as fallback (when not in free-fly mode)
            orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05;
            orbitControls.screenSpacePanning = false;
            orbitControls.maxPolarAngle = Math.PI;
            orbitControls.enabled = true;  // Start with orbit controls
            
            // Movement state for free-fly mode
            const moveState = {
                forward: false,
                backward: false,
                left: false,
                right: false,
                up: false,
                down: false,
                speed: 0.5
            };
            
            // Grid helper (XY plane since Z is up)
            gridHelper = new THREE.GridHelper(100, 50, 0x444444, 0x222222);
            gridHelper.rotation.x = Math.PI / 2;  // Rotate to XY plane
            scene.add(gridHelper);
            
            // Coordinate axes
            const axesHelper = new THREE.AxesHelper(10);
            scene.add(axesHelper);
            
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // Directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(10, 10, 20);
            scene.add(directionalLight);
            
            // Initialize point cloud with better visibility settings
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.PointsMaterial({
                size: pointSize,
                vertexColors: true,
                sizeAttenuation: true,  // Points get smaller with distance (realistic)
                transparent: false,
                opacity: 1.0,
                depthTest: true,
                depthWrite: true
            });
            pointCloud = new THREE.Points(geometry, material);
            scene.add(pointCloud);
            
            // Setup keyboard controls for free-fly mode
            setupKeyboardControls(moveState);
            
            // Setup pointer lock for free-fly mode
            setupPointerLock(pointerControls, moveState);
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
            
            // Connect WebSocket
            connectWebSocket();
            
            // Start animation loop
            animate();
        }
        
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
                console.log('WebSocket connected');
                document.getElementById('status-indicator').className = 'status-indicator status-connected';
                document.getElementById('loading').style.display = 'none';
            };
            
            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    updatePointCloud(data);
                    updateStats(data);
                    lastDataTime = Date.now();
                } catch (e) {
                    console.error('Error parsing WebSocket message:', e);
                }
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                document.getElementById('status-indicator').className = 'status-indicator status-disconnected';
            };
            
            ws.onclose = () => {
                console.log('WebSocket disconnected');
                document.getElementById('status-indicator').className = 'status-indicator status-disconnected';
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').textContent = 'Reconnecting...';
                
                // Attempt to reconnect after 2 seconds
                setTimeout(connectWebSocket, 2000);
            };
        }
        
        function updatePointCloud(data) {
            if (!data.points || data.num_points === 0) {
                return;
            }
            
            const positions = new Float32Array(data.num_points * 3);
            const colors = new Float32Array(data.num_points * 3);
            
            // Update ego position from server data (more accurate than calculating from points)
            if (data.ego_transform) {
                egoPosition.x = data.ego_transform.x;
                egoPosition.y = data.ego_transform.y;
                egoPosition.z = data.ego_transform.z;
                
                // Update camera to follow ego vehicle (smooth interpolation)
                if (followMode) {
                    // Calculate vehicle's forward direction from rotation (if available)
                    let forwardX = -50;  // Default: behind vehicle (doubled distance)
                    let forwardY = 0;
                    
                    if (data.ego_transform.yaw !== undefined) {
                        const yawRad = data.ego_transform.yaw * Math.PI / 180;
                        // Camera positioned behind vehicle (opposite to forward direction)
                        forwardX = -50 * Math.cos(yawRad);
                        forwardY = -50 * Math.sin(yawRad);
                    }
                    
                    const targetCamPos = new THREE.Vector3(
                        egoPosition.x + forwardX,  // Behind vehicle
                        -(egoPosition.y + forwardY),  // Offset to side (negated for coordinate fix)
                        egoPosition.z + 40         // Above (doubled height)
                    );
                    
                    const targetLookAt = new THREE.Vector3(
                        egoPosition.x,  // Look at vehicle position
                        -egoPosition.y,  // Negated for coordinate fix
                        egoPosition.z
                    );
                    
                    // Smooth camera movement (lerp factor 0.1 for smooth but responsive)
                    camera.position.lerp(targetCamPos, 0.1);
                    
                    // Make camera look at ego vehicle
                    const currentLookAt = new THREE.Vector3();
                    camera.getWorldDirection(currentLookAt);
                    currentLookAt.multiplyScalar(100).add(camera.position);
                    currentLookAt.lerp(targetLookAt, 0.15);
                    camera.lookAt(currentLookAt);
                }
            }
            
            // Build point cloud geometry
            for (let i = 0; i < data.num_points; i++) {
                // Positions (CARLA uses X-forward, Y-right, Z-up)
                // IMPORTANT: Negate Y to fix left/right mirroring
                positions[i * 3] = data.points.x[i];
                positions[i * 3 + 1] = -data.points.y[i];  // Negate Y to fix mirroring
                positions[i * 3 + 2] = data.points.z[i];
                
                // Colors based on semantic tag
                const tag = data.points.tag[i];
                const color = new THREE.Color(SEMANTIC_COLORS[tag] || 0x808080);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            pointCloud.geometry.dispose();
            pointCloud.geometry = geometry;
        }
        
        function updateStats(data) {
            document.getElementById('point-count').textContent = data.num_points.toLocaleString();
            document.getElementById('vehicle-count').textContent = data.num_vehicles;
            
            const latency = Date.now() - lastDataTime;
            document.getElementById('latency').textContent = `${latency} ms`;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Update appropriate controls based on mode
            if (freeFlyMode && pointerControls.isLocked) {
                updateFreeFlyMovement(moveState);
            } else if (!freeFlyMode && !followMode) {
                orbitControls.update();
            }
            // Follow mode updates are handled in updatePointCloud
            
            renderer.render(scene, camera);
            
            // Calculate FPS
            frameCount++;
            const now = Date.now();
            if (now - lastFrameTime >= 1000) {
                const fps = Math.round((frameCount * 1000) / (now - lastFrameTime));
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastFrameTime = now;
            }
        }
        
        function setupKeyboardControls(moveState) {
            orbitControls.target.set(0, 0, 0);
            orbitControls.update();
            
            // Exit any special modes
            followMode = false;
            freeFlyMode = false;
            orbitControls.enabled = true;
            updateControlButtons();
        }
        
        function toggleFollowMode() {
            followMode = !followMode;
            
            if (followMode) {
                // Disable other modes
                freeFlyMode = false;
                orbitControls.enabled = false;
                if (pointerControls.isLocked) pointerControls.unlock();
            } else {
                orbitControls.enabled = true;
            }
            
            updateControlButtons();
        }
        
        function toggleFreeFly() {
            freeFlyMode = !freeFlyMode;
            
            if (freeFlyMode) {
                // Disable other modes
                followMode = false;
                orbitControls.enabled = false;
                console.log('Free-fly mode enabled. Click canvas and use WASD + mouse to fly around.');
            } else {
                orbitControls.enabled = true;
                if (pointerControls.isLocked) pointerControls.unlock();
            }
            
            updateControlButtons();
        }
        
        function updateControlButtons() {
            const followBtn = document.getElementById('follow-btn');
            const freeFlyBtn = document.getElementById('freefly-btn');
            
            followBtn.textContent = followMode ? 'Disable Follow' : 'Enable Follow';
            followBtn.style.backgroundColor = followMode ? '#f44336' : '#4CAF50';
            
            freeFlyBtn.textContent = freeFlyMode ? 'Disable Free-Fly' : 'Enable Free-Fly';
            freeFlyBtn.style.backgroundColor = freeFlyMode ? '#f44336' : '#4CAF50';
        }
        
        function togglePointSize() {
            // Cycle through sizes: 0.2 -> 0.5 -> 1.0 -> 0.2
            if (pointSize < 0.3) pointSize = 0.5;
            else if (pointSize < 0.7) pointSize = 1.0;
            else pointSize = 0.2;
            
            pointCloud.material.size = pointSize;
            document.getElementById('size-btn').textContent = `Point Size: ${pointSize.toFixed(1)}`
            document.addEventListener('keyup', (event) => {
                switch(event.code) {
                    case 'KeyW': moveState.forward = false; break;
                    case 'KeyS': moveState.backward = false; break;
                    case 'KeyA': moveState.left = false; break;
                    case 'KeyD': moveState.right = false; break;
                    case 'Space': moveState.up = false; break;
                    case 'ShiftLeft': moveState.down = false; break;
                }
            });
        }
        
        function setupPointerLock(controls, moveState) {
            // Click to lock pointer in free-fly mode
            renderer.domElement.addEventListener('click', () => {
                if (freeFlyMode && !controls.isLocked) {
                    controls.lock();
                }
            });
            
            controls.addEventListener('lock', () => {
                console.log('Pointer locked - Use WASD to move, Space/Shift for up/down, ESC to exit');
            });
            
            controls.addEventListener('unlock', () => {
                console.log('Pointer unlocked');
            });
        }
        
        function updateFreeFlyMovement(moveState) {
            const direction = new THREE.Vector3();
            const right = new THREE.Vector3();
            
            camera.getWorldDirection(direction);
            right.crossVectors(camera.up, direction).normalize();
            
            const velocity = new THREE.Vector3();
            
            if (moveState.forward) velocity.add(direction.multiplyScalar(moveState.speed));
            if (moveState.backward) velocity.add(direction.multiplyScalar(-moveState.speed));
            if (moveState.right) velocity.add(right.multiplyScalar(-moveState.speed));
            if (moveState.left) velocity.add(right.multiplyScalar(moveState.speed));
            if (moveState.up) velocity.z += moveState.speed;
            if (moveState.down) velocity.z -= moveState.speed;
            
            camera.position.add(velocity);
        }
        
        function exitFreeFly() {
            if (pointerControls.isLocked) {
                pointerControls.unlock();
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function resetCamera() {
            camera.position.set(-25, 0, 20);
            controls.target.set(0, 0, 0);
            controls.update();
        }
        
        function toggleFollowMode() {
            followMode = !followMode;
            const btn = document.getElementById('follow-btn');
            btn.textContent = followMode ? 'Disable Follow' : 'Enable Follow';
            btn.style.backgroundColor = followMode ? '#f44336' : '#4CAF50';
        }
        
        function togglePointSize() {
            pointSize = pointSize === 0.1 ? 0.3 : 0.1;
            pointCloud.material.size = pointSize;
        }
        
        function toggleGrid() {
            showGrid = !showGrid;
            gridHelper.visible = showGrid;
        }
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
